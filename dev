kernel/fs.c:120:// not stored on disk: ip->ref and ip->valid.
kernel/fs.c:131://   is free if ip->ref is zero. Otherwise ip->ref tracks
kernel/fs.c:138://   table entry is only correct when ip->valid is 1.
kernel/fs.c:140://   the disk and sets ip->valid, while iput() clears
kernel/fs.c:141://   ip->valid if ip->ref has fallen to zero.
kernel/fs.c:150://   ... examine and modify ip->xxx ...
kernel/fs.c:158:// pathname lookup. iget() increments ip->ref so that the inode
kernel/fs.c:166:// entries. Since ip->ref indicates whether an entry is free,
kernel/fs.c:167:// and ip->dev and ip->inum indicate which i-node an entry
kernel/fs.c:170:// An ip->lock sleep-lock protects all ip-> fields other than ref,
kernel/fs.c:171:// dev, and inum.  One must hold ip->lock in order to
kernel/fs.c:172:// read or write that inode's ip->valid, ip->size, ip->type, &c.
kernel/fs.c:205:    if(dip->type == 0){  // a free inode
kernel/fs.c:207:      dip->type = type;
kernel/fs.c:218:// Must be called after every change to an ip->xxx field
kernel/fs.c:220:// Caller must hold ip->lock.
kernel/fs.c:227:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel/fs.c:228:  dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel/fs.c:229:  dip->type = ip->type;
kernel/fs.c:230:  dip->major = ip->major;
kernel/fs.c:231:  dip->minor = ip->minor;
kernel/fs.c:232:  dip->nlink = ip->nlink;
kernel/fs.c:233:  dip->size = ip->size;
kernel/fs.c:234:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
kernel/fs.c:252:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
kernel/fs.c:253:      ip->ref++;
kernel/fs.c:257:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
kernel/fs.c:266:  ip->dev = dev;
kernel/fs.c:267:  ip->inum = inum;
kernel/fs.c:268:  ip->ref = 1;
kernel/fs.c:269:  ip->valid = 0;
kernel/fs.c:281:  ip->ref++;
kernel/fs.c:294:  if(ip == 0 || ip->ref < 1)
kernel/fs.c:297:  acquiresleep(&ip->lock);
kernel/fs.c:299:  if(ip->valid == 0){
kernel/fs.c:300:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel/fs.c:301:    dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel/fs.c:302:    ip->type = dip->type;
kernel/fs.c:303:    ip->major = dip->major;
kernel/fs.c:304:    ip->minor = dip->minor;
kernel/fs.c:305:    ip->nlink = dip->nlink;
kernel/fs.c:306:    ip->size = dip->size;
kernel/fs.c:307:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
kernel/fs.c:309:    ip->valid = 1;
kernel/fs.c:310:    if(ip->type == 0)
kernel/fs.c:319:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
kernel/fs.c:322:  releasesleep(&ip->lock);
kernel/fs.c:337:  if(ip->ref == 1 && ip->valid && ip->nlink == 0){
kernel/fs.c:340:    // ip->ref == 1 means no other process can have ip locked,
kernel/fs.c:342:    acquiresleep(&ip->lock);
kernel/fs.c:347:    ip->type = 0;
kernel/fs.c:349:    ip->valid = 0;
kernel/fs.c:351:    releasesleep(&ip->lock);
kernel/fs.c:356:  ip->ref--;
kernel/fs.c:372:// are listed in ip->addrs[].  The next NINDIRECT blocks are
kernel/fs.c:373:// listed in block ip->addrs[NDIRECT].
kernel/fs.c:384:    if((addr = ip->addrs[bn]) == 0)
kernel/fs.c:385:      ip->addrs[bn] = addr = balloc(ip->dev);
kernel/fs.c:392:    if((addr = ip->addrs[NDIRECT]) == 0)
kernel/fs.c:393:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
kernel/fs.c:394:    bp = bread(ip->dev, addr);
kernel/fs.c:397:      a[bn] = addr = balloc(ip->dev);
kernel/fs.c:408:    if ((addr = ip->addrs[NDIRECT + 1]) == 0)
kernel/fs.c:409:      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);
kernel/fs.c:417:// Caller must hold ip->lock.
kernel/fs.c:426:    if(ip->addrs[i]){
kernel/fs.c:427:      bfree(ip->dev, ip->addrs[i]);
kernel/fs.c:428:      ip->addrs[i] = 0;
kernel/fs.c:432:  if(ip->addrs[NDIRECT]){
kernel/fs.c:433:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
kernel/fs.c:437:        bfree(ip->dev, a[j]);
kernel/fs.c:440:    bfree(ip->dev, ip->addrs[NDIRECT]);
kernel/fs.c:441:    ip->addrs[NDIRECT] = 0;
kernel/fs.c:444:  ip->size = 0;
kernel/fs.c:449:// Caller must hold ip->lock.
kernel/fs.c:453:  st->dev = ip->dev;
kernel/fs.c:454:  st->ino = ip->inum;
kernel/fs.c:455:  st->type = ip->type;
kernel/fs.c:456:  st->nlink = ip->nlink;
kernel/fs.c:457:  st->size = ip->size;
kernel/fs.c:461:// Caller must hold ip->lock.
kernel/fs.c:470:  if(off > ip->size || off + n < off)
kernel/fs.c:472:  if(off + n > ip->size)
kernel/fs.c:473:    n = ip->size - off;
kernel/fs.c:476:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel/fs.c:489:// Caller must hold ip->lock.
kernel/fs.c:501:  if(off > ip->size || off + n < off)
kernel/fs.c:507:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel/fs.c:517:  if(off > ip->size)
kernel/fs.c:518:    ip->size = off;
kernel/fs.c:522:  // block to ip->addrs[].
kernel/fs.c:649:    if(ip->type != T_DIR){
kernel/sysfile.c:135:  if(ip->type == T_DIR){
kernel/sysfile.c:141:  ip->nlink++;
kernel/sysfile.c:148:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
kernel/sysfile.c:161:  ip->nlink--;
kernel/sysfile.c:211:  if(ip->nlink < 1)
kernel/sysfile.c:213:  if(ip->type == T_DIR && !isdirempty(ip)){
kernel/sysfile.c:221:  if(ip->type == T_DIR){
kernel/sysfile.c:227:  ip->nlink--;
kernel/sysfile.c:255:    if(type == T_FILE && (ip->type == T_FILE || ip->type == T_DEVICE))
kernel/sysfile.c:265:  ip->major = major;
kernel/sysfile.c:266:  ip->minor = minor;
kernel/sysfile.c:267:  ip->nlink = 1;
kernel/sysfile.c:273:    // No ip->nlink++ for ".": avoid cyclic ref count.
kernel/sysfile.c:274:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
kernel/sysfile.c:278:  if(dirlink(dp, name, ip->inum) < 0)
kernel/sysfile.c:312:    if(ip->type == T_DIR && omode != O_RDONLY){
kernel/sysfile.c:319:  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
kernel/sysfile.c:333:  if(ip->type == T_DEVICE){
kernel/sysfile.c:335:    f->major = ip->major;
kernel/sysfile.c:344:  if((omode & O_TRUNC) && ip->type == T_FILE){
kernel/sysfile.c:403:  if(ip->type != T_DIR){
